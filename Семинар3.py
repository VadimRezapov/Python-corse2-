# Задание №1
# ✔ Вручную создайте список с целыми числами, которые 
# повторяются. Получите новый список, который содержит 
# уникальные (без повтора) элементы исходного списка. 
# ✔ *Подготовьте два решения, короткое и длинное, которое 
# не использует другие коллекции помимо списков.
def Zadacha1():
    from random import randint as ri
    print(my_list := [ri(1, 10) for _ in range(15)]) ## Создан список с помощью модуля randint и при помощи моржевого оператора := присвоили my_list
    print(list(set(my_list))) ## Через функцию set (в данном случае set это не тип данных, она работает как функция"приведение типов") (list в данном случае тоже как функция), завернули функцию в (set(my_list))) list
# Получаем список с уникальными элементами 
# Решение 
#[3, 2, 2, 2, 10, 1, 2, 2, 8, 6, 2, 1, 5, 10, 5]
# [1, 2, 3, 5, 6, 8, 10]


# Задание №2
# Погружение в Python | Коллекции
# ✔ Создайте вручную кортеж содержащий элементы разных типов. 
# ✔ Получите из него словарь списков, где:
# ключ — тип элемента,
# значение — список элементов данного типа.

def Zadacha2():
    my_tuple = (1, 'word', 'second', 3.14, True, [1, 2, 3], 2, {'key': 'value'}, 3, False, 'строка') # Создаем переменную и помещаем в нее кореж
    
    result = {} # Создаем переменную result и савим фигурные скобки. Фигурные скобки в данном случае будут по умолчанию словарем, а не множеством

    for item in my_tuple: # Создаем цыкл и проходимся по элементам переменной my_tuple
        if type(item) in result: # Далее спрашиваем Есть ли такой ключ type(item) в result 
            result[type(item)].append(item) # Далее делаем result, берем ключ type(item) и говорим, что необходимо сделать .append(item). 
            # Если у нас такой ключ есть, то мы проводим .append(item)
        else: # Иначе
            result[type(item)] = [item] # Если такого ключа нет, то мы берем и создаем это ключ result[type(item)] и говорим, что здесь будет список из item
            
    print(result)        

Zadacha2()