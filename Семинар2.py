# Создайте несколько переменных разных типов.
# Проверьте к какому типу относятся созданные переменные. 

def Task1():
    number = 11
    bl = True
    string = 'Строка'
    f_number = 3.14
    nont = None

    print(type(number))
    print(type(bl))
    print(type(string))
    print(type(f_number))
    print(type(nont))


# Создайте в переменной data список значений разных типов перечислив их через
# запятую внутри квадратных скобок. Для каждого элемента в цикле выведите:
# ✔ порядковый номер начиная с единицы
# ✔ значение
# ✔ адрес в памяти
# ✔ размер в памяти
# ✔ хэш объекта
# ✔ результат проверки на целое число только если он положительный
# ✔ результат проверки на строку только если он положительный
# Добавьте в список повторяющиеся элементы и сравните на результаты.
    
def Task2():
    import sys
    data = [1,'trewfs',3.14, True,-1,'asdasd']
    for index, value in enumerate(data, 1):
        print(f'порядковый номер: {index}')
        print(f"значение: {value}")
        print(f'адрес в памяти: {id(value)}')
        print((f'размер в памяти: {value.__sizeof__()} байт'))
        print(f'хеш объекта: {hash(value)}')

        if isinstance(value, int):
            print(f'Результат проверки на целое число: True')
        print(f'результат проверки на строку: ', 'True' if isinstance(value, str) else 'False')
        print('\n',"=="*40)


# Задание №3
# ✔ Напишите программу, которая получает целое число и возвращает
# его двоичное, восьмеричное строковое представление.
# ✔ Функции bin и oct используйте для проверки своего
# результата, а не для решения.
# Дополнительно:
# ✔ Попробуйте избежать дублирования кода
# в преобразованиях к разным системам счисления
# ✔ Избегайте магических чисел
# ✔ Добавьте аннотацию типов где это возможно
        
#def Task3():
# Функция bin выводит двоичное значение # 
# Функиця oct выводит восмеричное значение. Преобразование целого числа в восьмеричную систему счисления #     
    
BIN = 2
OCT = 8
number = 46


def num_to_base(orig_number, base):
    result = ''
while orig_number != 0:
    result = str(orig_number % base) + result
orig_number //= base
return result


print('0b' + num_to_base(number, BIN))
print(bin(number))
print('0o' + num_to_base(number, OCT))
print(oct(number))



